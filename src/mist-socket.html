<script src="../bower_components/sockjs-client/dist/sockjs.min.js"></script>
<script>
    CSRF_TOKEN = '';
    DEBUG_SOCKET = false;
    STRIPE_PUBLIC_APIKEY = ''
    Polymer({
        is: 'mist-socket',
        url: '/socket',
        properties: {
            socket: {
                type: Object,
                value: false
            },
            openRequests: {
                type: Array,
                value: []
            },
            model: {
                type: Object,
                notify: true
            },
            initialized: {
                type: Boolean,
                value: false
            },
            onboarding: {
                type: Object,
                value: {
                    isLoadingClouds: true,
                    isLoadingMachines: true,
                    isLoadingImages: true,
                    isLoadingKeys: true,
                    isLoadingNetworks: true,
                    isLoadingZones: true,
                    isLoadingTunnels: true,
                    isLoadingScripts: true,
                    isLoadingSchedules: true,
                    isLoadingTemplates: true,
                    isLoadingStacks: true,
                    isLoadingTeams: true,
                    isLoadingIncidents: true
                },
                notify: true
            },
            term: {
                type: Object
            }
        },

        observers: [
            "_updateIsOverusing(model.user, model.org, model.machinesArray)"
        ],

        ready: function () {
            // Create the socket if it does not exist
            console.warn('ready');
            if (this.socket)
                return;
            this.connect();
        },

        connect: function () {
            console.warn('connecting at ', this.url);
            // Create the SockJS object
            this.socket = new SockJS(this.url, null, {
                'transports': ['websocket', 'xhr-polling']
            });

            // Connect the receiver
            var receiver = this.receive.bind(this);
            this.socket.onmessage = function (e) {
                receiver(e.data);
            };

            var that = this;

            // Handle error & close
            this.socket.onerror = function () {
                console.warn('CONNECTION ERROR');
                that.async(that.connect, 1000);
            };
            this.socket.onclose = function () {
                console.warn('CONNECTION CLOSED');
                that.async(that.connect, 1000);
            };
            this.socket.onheartbeat = this.heartbeat;

            // When socket connects prepare channels
            this.socket.onopen = function () {
                console.log('CONNECTION ESTABLISHED');
                that.send('sub', 'main');
                that.send('msg', 'main', 'ready');
                that.send('sub', 'logs');
                that.send('msg', 'logs', 'ready');
                that.set('initialized', true);
            };

            // Initialize main handlers
            this.handlers = {
                main: {
                    list_clouds: function (data) {
                        that.debounce(that._updateClouds(data), function () {
                            // console.debug('list_clouds', data);
                        }, 250);
                    },
                    list_keys: function (data) {
                        that.debounce(that._updateKeys(data), function () {
                            // console.debug('list_keys', data);
                        }, 250);
                    },
                    list_scripts: function (data) {
                        that.debounce(that._updateScripts(data), function () {
                            // console.debug('list_scripts', data);
                        }, 250);
                    },
                    list_schedules: function (data) {
                        that.debounce(that._updateSchedules(data), function () {
                            // console.debug('list_schedules', data);
                        }, 250);
                    },
                    list_templates: function (data) {
                        console.warn('got templates', data);
                        that.debounce(that._updateTemplates(data), function () {
                            // console.debug('list_templates', data);
                        }, 250);
                    },
                    list_stacks: function (data) {
                        console.warn('got stacks', data);
                        that.debounce(that._updateStacks(data), function () {
                            // console.debug('list_stacks', data);
                        }, 250);
                    },
                    list_machines: function (data) {
                        that.debounce(that._updateMachines(data), function () {
                            // console.debug('list_machines', data);
                        }, 250);
                    },
                    list_images: function (data) {
                        that.debounce(that._updateImages(data), function () {
                            // console.log('list_images', data);
                        }, 250);
                    },
                    list_sizes: function (data) {
                        that.debounce(that._updateSizes(data), function () {
                            // console.debug('list_sizes', data);
                        }, 250);
                    },
                    list_locations: function (data) {
                        that.debounce(that._updateLocations(data), function () {
                            // console.debug('list_locations', data);
                        }, 250);
                    },
                    list_networks: function (data) {
                        that.debounce(that._updateNetworks(data), function () {
                            // console.debug('list_networks', data);
                        }, 250);
                    },
                    list_zones: function (data) {
                        that.debounce(that._updateZones(data), function () {
                            // console.debug('list_zones', data);
                        }, 250);
                    },
                    list_tunnels: function (data) {
                        that.debounce(that._updateTunnels(data), function () {
                            // console.debug('list_networks', data);
                        }, 250);
                    },
                    list_projects: function (data) {
                        that.debounce(that._updateProjects(data), function () {
                            // console.debug('list_projects', data);
                        }, 250);
                    },
                    list_tags: function (data) {
                        that.debounce(that._updateTags(data), function () {
                            console.debug('list_tags', data);
                        }, 250);
                    },
                    ping: function (data) {
                        // console.debug('ping', data);
                        that._ping(data);
                    },
                    probe: function (data) {
                        // console.debug('probe', data);
                        that._probe(data);
                    },
                    monitoring: function (data) {
                        that.debounce(that._updateMonitoring(data), function () {
                            // console.debug('monitoring', data);
                        }, 250);
                    },
                    reload: function (data) {
                        that.debounce(that._reloadPage(data), function () {
                            console.debug('reloading page', data);
                        }, 250);
                    },
                    user: function (data) {
                        that.debounce(that._updateUser(data), function () {
                            console.debug('Loaded user data');
                        }, 250);
                    },
                    org: function (data) {
                        console.warn('Loaded org data');
                        that.debounce(that._updateOrg(data), function () {
                            console.debug('Loaded org data');
                        }, 250);
                    },
                    logout: function (data) {
                        document.location.pathname = '/';
                    },
                    stats: function (data) {
                        // console.log(that.openRequests)
                        if (!that.openRequests[data.request_id])
                            console.warn('cannot find open request', data.request_id)
                        else {
                            that.openRequests[data.request_id](data);
                            delete that.openRequests[data.request_id];
                        }
                    }
                },
                shell: {
                    shell_data: function (data) {
                        if (that.term) {
                            that.term.write(data);
                        } else {
                            console.warn(
                                'received shell data from socket but the terminal is not open',
                                data);
                        }
                    }
                },
                logs: {
                    logs: function (data) {
                        console.warn('received log entries from socket', data);
                    },
                    event: function (data) {
                        if (DEBUG_SOCKET)
                            console.debug('received log event', data);
                        var loglist = document.querySelector('log-list');
                        if (loglist) {
                            loglist.eventReceived(data);
                        } else {
                            console.warn('No log-list found in DOM to consume log event');
                        }
                    },
                    open_incidents: function (data) {
                        if (DEBUG_SOCKET)
                            console.debug('got incidents', data);
                        that.debounce(that._updateIncidents(data), function () {
                            console.debug('Loaded incidents data');
                        }, 250);
                    },
                    open_jobs: function (data) {
                        if (DEBUG_SOCKET)
                            console.debug('got jobs', data);
                        that.set('model.jobs', data);
                    },
                    open_sessions: function (data) {
                        if (DEBUG_SOCKET)
                            console.debug('got sessions', data);
                        that.set('model.sessions', data);
                    },
                    open_shells: function (data) {
                        if (DEBUG_SOCKET)
                            console.debug('got shells', data);
                        that.set('model.shells', data);
                    }
                }
            };
        },

        heartbeat: function () {
            console.debug('got heartbeat');
            this.send('h'); // reply with empty frame
        },

        getStats: function (data, callback) {
            var reqId = this.generateGuid(); // Math.floor(10000 * Math.random());
            data[5] = reqId;
            this.openRequests[reqId] = callback;
            this.send('msg', 'main', 'stats', data);
        },

        generateGuid: function () {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            }
            return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                s4() + '-' + s4() + s4() + s4();
        },

        send: function (type, namespace, body, params) {
            if (namespace == undefined)
                namespace = 'main';

            var payload = type + ',' + namespace;

            if (body !== undefined)
                payload += ',' + body;

            if (params !== undefined)
                payload += ',' + JSON.stringify(params);

            this.socket.send(payload);
            if (DEBUG_SOCKET)
                console.debug('SENT: ' + payload);
        },

        receive: function (message) {
            if (DEBUG_SOCKET)
                console.debug('RECEIVED: ' + message);

            var parts = message.split(',');
            var type = parts[0],
                namespace = parts[1];
            var body = JSON.parse(parts.splice(2).join(','));
            if (this.handlers[namespace] === undefined)
                console.warn('Unknown namespace', namespace);
            var endpoint = this.handlers[namespace][Object.keys(body)[0].trim()];
            if (endpoint === undefined)
                console.warn('Unknown endpoint', Object.keys(body)[0], 'in namespace', namespace);
            else
                endpoint(body[Object.keys(body)[0]]);
        },

        _reloadPage: function (data) {
            console.warn('reloading', data);
            document.location.reload();
        },

        _updateModel: function (section, data, primaryField) {
            var changed = false, // we wont update the model if it hasn't changed
                pending = this.get('model.pending.' + section);

            // if the received data array has different length than the respective
            // model array, then things must have changed since last update
            if (data.length != this.get('model.' + section + 'Array.length')) {
                // console.debug('0. length', data.length, this.get('model.' + section + 'Array.length'));
                changed = true;
            }

            // For each item in the received data array
            for (var i = 0; i < data.length; i++) {
                // If we know things have changed no need to keep checking
                if (changed)
                    break;
                // check if _id is used instead of id
                if (!data[i].id) {
                    data[i].id = data[i]._id
                }
                // Check if item exists in respective model
                // var item = this.get('model.' + section + '.' + data[i].id);
                // patch for when data[i].id is of type '127.0.0.1'
                var path = this.get('model.' + section);
                var item = path[data[i].id];
                if (!item) { // If does not exist then model needs to be updated
                    // console.debug('1. data[i].id', data[i], this.get('model.' + section + '.' + data[i].id));
                    changed = true;
                    break;
                }

                // check if all fields of the data item exist in the model item
                var dataKeys = Object.keys(data[i]),
                    modelKeys = Object.keys(item);
                for (var k = 0; k < dataKeys.length; k++) {
                    // Do not update model just for the last_seen property
                    if (dataKeys[k] == 'last_seen') {
                        continue;
                    }
                    if (modelKeys.indexOf(dataKeys[k]) == -1) {
                        // If something is missing the model needs to be updated
                        console.debug('2. model', modelKeys.indexOf(dataKeys[k]), dataKeys[k]);
                        changed = true;
                        break;
                    }
                    // If some field changed the model needs to be updated
                    if (data[i][dataKeys[k]] != undefined && JSON.stringify(data[i][dataKeys[k]])
                        .localeCompare(JSON.stringify(item[dataKeys[k]]))) {
                        // console.debug('localeCompare',JSON.stringify(data[i][dataKeys[k]]).localeCompare(JSON.stringify(item[dataKeys[k]])));
                        console.debug('property ', dataKeys[k], ' changed in ', item);
                        var oldVal = JSON.stringify(item[dataKeys[k]]),
                            newVal = JSON.stringify(data[i][dataKeys[k]]);
                        console.debug('Old value: ', oldVal, oldVal.length);
                        console.debug('New value: ', newVal, newVal.length);
                        changed = true;
                        break;
                    }
                }

                if (changed)
                    break;
            }

            if (changed) {
                console.debug('updating', section);
                this.set('model.' + section, _generateMap(data, primaryField));
                this.set('model.' + section + 'Array', data);
            } else {
                if (DEBUG_SOCKET)
                    console.debug('no need to update', section);
            }

            if (pending) {
                this.set('model.pending.' + section, false);
            }

            return changed;
        },

        _updateClouds: function (data) {
            // console.log('_updateClouds');
            if (data.length && this.get('onboarding.hasCloud') != true)
                this.set('onboarding.hasCloud', true);
            if (!data.length) {
                this.set('onboarding.hasCloud', false);
                this.set('onboarding.isLoadingMachines', false);
                this.set('onboarding.isLoadingImages', false);
                this.set('onboarding.isLoadingNetworks', false);
            }
            var ret = this._updateModel('clouds', data);
            this.set('onboarding.isLoadingClouds', false);

            if (this.model != undefined && data) {
                data.forEach(function (c) {
                    if (!c.enabled) {
                        this.cleanUpResources(c.id);
                    }
                }, this)
            }
            if (!data || this.model.cloudsArray.length == 0) {
                this.cleanUpResources();
            }

            // the case when clouds have loaded but handlers list_machines/list_images/list_networks
            // have never been triggered (ex. all clouds are disabled, list_machines never gets data)
            var cloudsResources = !(!this.model.machines && !this.model.networks && !this.model.images);
            if (data.length && !cloudsResources && ret)
                cloudsResources = data.map(function (d) {
                    return d.machines || d.images || d.networks ? true : false;
                }).reduce(function (b1, b2) {
                    return b1 || b2;
                });
            if (!cloudsResources) {
                this.set('onboarding.isLoadingMachines', false);
                this.set('onboarding.isLoadingImages', false);
                this.set('onboarding.isLoadingNetworks', false);
            }
            return ret;
        },

        _updateMonitoring: function (data) {
            console.warn('got monitoring', data);
            if (data.length && this.get('onboarding.hasMonitoring') != true)
                this.set('onboarding.hasMonitoring', true);
            if (!data) //data is an Object
                this.set('onboarding.hasMonitoring', false);
            this.set('model.pending.monitoring', false);
            // inform machines that have rules
            if (data.rules) {
                for (var rule in data.rules) {
                    if (this.model.clouds[rule.cloud] && this.model.clouds[rule.cloud].machines[rule.machine]) {
                        if (!this.get('model.clouds.' + rule.cloud + '.machines.' + rule.machine + '.rules')) {
                            this.set('model.clouds.' + rule.cloud + '.machines.' + rule.machine + '.rules', [
                                rule
                            ])
                            // console.log('// inform machines that have rules ', rule.cloud, rule.machine, this.model.clouds[rule.cloud].machines[rule.machine].rules);
                        } else
                            this.push('model.clouds.' + rule.cloud + '.machines.' + rule.machine + '.rules',
                                rule)
                    }
                }
            }
            return this.set('model.monitoring', data);
        },

        _updateUser: function (data) {
            this.set('model.user', data);
            if (data) {
                CSRF_TOKEN = data.csrf_token;
                STRIPE_PUBLIC_APIKEY = data.stripe_public_apikey;
            }
        },

        _updateOrg: function (data) {
            this.set('onboarding.isLoadingTeams', false);
            this._updateModel('teams', data.teams);
            this._updateModel('members', data.members);
            data.teams = data.members = undefined;
            this.set('model.org', data);
        },

        _updateKeys: function (data) {
            this.set('onboarding.isLoadingKeys', false);
            if (data) {
                for (var i = 0; i < data.length; i++) {
                    var key = data[i];
                    if (this.model.clouds && key.machines)
                        key.machines.forEach(function (m, index) {
                            var cloud = m[0],
                                machine = m[1];
                            if (this.model.clouds && this.model.clouds[cloud] && this.model.clouds[
                                    cloud].machines && this.model.clouds[cloud].machines[machine] &&
                                this.model.clouds[cloud].machines[machine].keys) {
                                // check if machine has this key, if not add
                                var keyexists = this.model.clouds[cloud].machines[machine].keys.find(
                                    function (k) {
                                        return k.name == key.name;
                                    });
                            }
                            if (!keyexists) {
                                if (!this.get('model.clouds.' + cloud + '.machines.' + machine +
                                        '.keys'))
                                    this.set('model.clouds.' + cloud + '.machines.' + machine + '.keys', [
                                        key
                                    ])
                                else
                                    this.push('model.clouds.' + cloud + '.machines.' + machine +
                                        '.keys', key)
                            }
                        }, this)
                }
            }
            return this._updateModel('keys', data);
        },

        _updateScripts: function (data) {
            this.set('onboarding.isLoadingScripts', false);
            return this._updateModel('scripts', data);
        },

        _updateSchedules: function (data) {
            this.set('onboarding.isLoadingSchedules', false);
            return this._updateModel('schedules', data);
        },

        _updateTemplates: function (data) {
            this.set('onboarding.isLoadingTemplates', false);
            return this._updateModel('templates', data);
        },

        _updateStacks: function (data) {
            this.set('onboarding.isLoadingStacks', false);
            return this._updateModel('stacks', data);
        },

        _updateSizes: function (data) {
            return this._updateModel('clouds.' + data.cloud_id + '.sizes', data.sizes);
        },

        _updateLocations: function (data) {
            return this._updateModel('clouds.' + data.cloud_id + '.locations', data.locations);
        },

        _updateImages: function (data) {
            // console.log('_updateImages');
            this.set('onboarding.isLoadingImages', false);
            var changed = this._updateModel('clouds.' + data.cloud_id + '.images', data.images);
            if (!changed)
                return false;

            self = this;
            var allImages = [];
            if (this.model != undefined) {
                this.model.cloudsArray.forEach(
                    function (cloud) {
                        if (cloud.imagesArray != undefined && cloud.enabled) {
                            cloud.imagesArray.forEach(function (image, index, arr) {
                                arr[index].icons = self._generateIcon(image);
                                arr[index].cloud = {
                                    'id': cloud.id,
                                    'title': cloud.title,
                                    'provider': cloud.provider
                                };
                                self.model.imagesArray.push(arr[index])
                            });
                        }
                        return allImages = allImages.concat(cloud.imagesArray != undefined ? cloud.imagesArray :
                            [])
                    });
            }

            this.set('model.imagesArray', allImages);
            this.set('model.images', _generateMap(allImages));
        },

        _updateMachines: function (data) {
            var changed = this._updateModel('clouds.' + data.cloud_id + '.machines', data.machines, 'machine_id');
            // console.log('machines',data.machines);
            if (!changed)
                return false;

            var allMachines = [];
            if (this.model != undefined && this.model.cloudsArray.length > 0) {
                this.model.cloudsArray.forEach(
                    function (cloud) {
                        if (cloud.machinesArray != undefined && cloud.enabled) {
                            cloud.machinesArray.forEach(function (machine) {
                                machine.cloud = {
                                    'id': cloud.id,
                                    'title': cloud.title,
                                    'provider': cloud.provider
                                };
                                // machine.keys = this._machineKeys(machine.machine_id, machine.cloud.id) || [];
                                machine.rules = this._machineRules(machine.machine_id, machine.cloud.id);
                            }, this);

                            return allMachines = allMachines.concat(cloud.machinesArray != undefined ?
                                cloud.machinesArray : [])
                        }
                    }, this);
            }

            if (data.length && this.get('model.onboarding.hasMachines') != true)
                this.set('model.onboarding.hasMachines', true);

            this.set('onboarding.isLoadingMachines', false);
            this.set('model.machinesArray', allMachines);
            this.set('model.machines', _generateMap(allMachines));
        },

        _updateNetworks: function (data) {
            this.set('onboarding.isLoadingNetworks', false);

            //update cloud's networks
            var cloudNetworks = [];
            if (this.model.clouds && this.model.clouds[data.cloud_id] && this.model.clouds[data.cloud_id].provider) {
                data.networks.private.forEach(function (net) {
                    if (net.id) {
                        net["network_type"] = "private";
                        net["provider"] = this.model.clouds[data.cloud_id].provider;
                        net["cloud_id"] = data.cloud_id;
                        cloudNetworks.push(net);
                    }
                }, this);
                data.networks.public.forEach(function (net) {
                    if (net.id) {
                        net["network_type"] = "public";
                        net["provider"] = this.model.clouds[data.cloud_id].provider;
                        net["cloud_id"] = data.cloud_id;
                        cloudNetworks.push(net);
                    }
                }, this);
            }
            // data.networks.routers.forEach(function(net){
            //     if (net.id){
            //         net["network_type"] = "router";
            //         net["provider"] = this.model.clouds[data.cloud_id].provider;
            //         net["cloud_id"] = data.cloud_id;
            //         cloudNetworks.push(net);
            //     }
            // }, this);

            // console.log(data);

            var changed = this._updateModel('clouds.' + data.cloud_id + '.networks', cloudNetworks);

            if (!changed)
                return false;

            this.set('model.clouds.' + data.cloud_id + '.networksArray', cloudNetworks);
            this.set('model.clouds.' + data.cloud_id + '.networks', _generateMap(cloudNetworks));

            //update all networks array
            var allNetworks = [];
            if (this.model != undefined) {
                this.model.cloudsArray.forEach(function (cloud) {
                    if (cloud.networksArray != undefined && cloud.enabled) {
                        cloud.networksArray.forEach(function (net) {
                            allNetworks.push(net);
                        })
                    }
                });
            }
            this.set('model.networksArray', allNetworks);
            this.set('model.networks', _generateMap(allNetworks));
        },
        _updateZones: function (data) {
            this.set('onboarding.isLoadingZones', false);

            //update cloud's Zones
            var cloudZones = [];
            if (this.model.clouds && this.model.clouds[data.cloud_id] && this.model.clouds[data.cloud_id].provider) {
                data.zones.forEach(function (zone) {
                    if (zone.id) {
                        zone['cloud_id'] = data.cloud_id;
                        zone['zone_type'] = zone['type'];
                        zone.records.forEach(function(record) {
                                record['record_type'] = record['type'];
                                record['zone_id'] = zone['id'];
                                record['cloud_id'] = zone['cloud_id'];
                                delete record['type'];
                            }
                        )
                        delete zone['type'];
                        if (this.model.clouds[data.cloud_id].provider == 'gce') {
                            zone['provider'] = 'Google'
                        } else if (this.model.clouds[data.cloud_id].provider == 'ec2') {
                            zone['provider'] = 'Route53'
                            zone.records.forEach(function(record) {
                                if (record['name'].length == 0) {
                                    record['name'] = zone.domain;
                                } else {
                                    record['name'] += '.' + zone.domain;
                                }
                            })
                        } else {
                            zone['provider'] = this.model.clouds[data.cloud_id].provider
                        }
                        cloudZones.push(zone);
                    }
                }, this);
            }
            // console.log(data);

            var changed = this._updateModel('clouds.' + data.cloud_id + '.zones', cloudZones);

            if (!changed)
                return false;

            this.set('model.clouds.' + data.cloud_id + '.zonesArray', cloudZones);
            this.set('model.clouds.' + data.cloud_id + '.zones', _generateMap(cloudZones));

            //update all zones array
            var allZones = [];
            var allRecords = [];
            if (this.model != undefined) {
                this.model.cloudsArray.forEach(function (cloud) {
                    if (cloud.zonesArray != undefined && cloud.enabled) {
                        cloud.zonesArray.forEach(function(zone) {
                            allZones.push(zone);
                            zone.records.forEach(function(record){
                                allRecords.push(record);
                            }) 
                        })
                    }
                });
            }
            this.set('model.zonesArray', allZones);
            this.set('model.zones', _generateMap(allZones));
            this.set('model.records', _generateMap(allRecords));
        },
        _updateTunnels: function (data) {
            this.set('onboarding.isLoadingTunnels', false);
            return this._updateModel('tunnels', data);
        },

        _updateIncidents: function (data) {
            this.set('onboarding.isLoadingIncidents', false);
            if (data) {
                for (var i = 0; i < data.length; i++) {
                    var inc = data[i];
                    inc.id = inc.incident_id
                }
            }
            return this._updateModel('incidents', data);
        },

        _updateProjects: function (data) {
            this.set('model.clouds.' + data.cloud_id + '.projects', _generateMap(data.projects));
            this.set('model.clouds.' + data.cloud_id + '.projectsArray', data.projects);
        },

        _updateTags: function (data) {
            console.warn('_updateTags not implemented. Got data', data);
        },

        _updateIsOverusing: function (user, org, machines) {
            var isOverUsing = false;
            // console.log('_updateIsOverusing', user, machines);
            if (this.model.user && this.model.machinesArray) {
                var isOverUsing = false;
                // user has free plan and more than 5 machines
                if ((!this.model.org.current_plan || !this.model.org.current_plan.title) && this.model.machinesArray.length > 5)
                    isOverUsing = true;
                // user has a paid plan and more than allowed machines
                else if (this.model.org.current_plan && this.model.org.current_plan.title && this.model.machinesArray.length > this.model.org.current_plan.machine_limit)
                    isOverUsing = true;
            }
            this.set('model.isOverUsing', isOverUsing);
        },

        _probe: function (data) {
            if (!this.model.probes)
                this.set('model.probes', {})
            try {
                var machine = this.model.machines[data.machine_uuid];
                this.set('model.probes.' + machine.id, data.result);
            } catch (e) {
                console.log('cannot find id for machine with cloud_id ', data.cloud_id, ' and machine_id', data.machine_id);
            }
        },

        _ping: function (data) {
            // TODO
        },

        _generateIcon: function (data) {
            var lexicon = ["ubuntu", "mongo", "aws", "suse", "fedora", "linux"];
            var keywords = [];
            for (var i = 0; i < lexicon.length; i++) {
                if (data.name.toLowerCase().search(lexicon[i]) > -1) {
                    keywords.push(lexicon[i]);
                }
            }
            return keywords;
        },

        _machineKeys: function (machineID, cloudID) {
            // console.log('Update _machineKeys',cloudID,machineID);
            if (machineID && cloudID) {
                var keys = this.model.keysArray.filter(function (k) {
                    return k.machines.find(function (m) {
                        return m[1] == machineID && m[0] == cloudID;
                    })
                });
                return keys || [];
            }
        },
        _machineRules: function (machineID, cloudID) {
            // if something has not initiaised
            if (!machineID || !cloudID || !this.model || !this.model.monitoring || !this.model.monitoring.rules ||
                !this.model.clouds || !this.model.clouds[cloudID] || !this.model.clouds[cloudID].machines ||
                !this.model.clouds[cloudID].machines[machineID]) {
                return [];
            } else {
                var rules = [];
                for (var rule in this.model.monitoring.rules) {
                    if (this.model.monitoring.rules[rule].machine == machineID && this.model.monitoring.rules[
                            rule].cloud == cloudID) {
                        //add rule only if it's not already added in the machine
                        var ruleExists = false;
                        if (this.model.clouds[cloudID].machines[machineID].rules) {
                            var ruleExists = this.model.clouds[cloudID].machines[machineID].rules.find(
                                function (r) {
                                    return r.id == this.model.monitoring.rules[rule].id
                                }, this);
                        }
                        if (!ruleExists) {
                            rules.push(this.model.monitoring.rules[rule]);
                        }
                    }
                }
                return rules;
            }
        },
        cleanUpResources: function (id) {
            var newMachinesArray = [],
                newImagesArray = [],
                newNetworksArray = [];
            if (id) {
                // machines
                newMachinesArray = this.model.machinesArray.filter(function (m) {
                    return m.cloud.id != id;
                });

                // images
                newImagesArray = this.model.imagesArray.filter(function (im) {
                    return im.cloud.id != id;
                });

                // networks
                newNetworksArray = this.model.networksArray.filter(function (n) {
                    return n.cloud_id != id;
                });
            }
            this.set('model.machinesArray', newMachinesArray);
            this.set('model.machines', _generateMap(newMachinesArray));

            this.set('model.imagesArray', newImagesArray);
            this.set('model.images', _generateMap(newImagesArray));

            this.set('model.networksArray', newNetworksArray);
            this.set('model.networks', _generateMap(newNetworksArray));
        }
    });

    var _generateMap = function (list, field) {
        var out = {};
        if (field == undefined)
            field = 'id';
        for (var i = 0; i < list.length; i++) {
            out[list[i][field]] = list[i];
        }
        return out;
    };
</script>
